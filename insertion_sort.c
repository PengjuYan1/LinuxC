#include <stdio.h>

/*      插入排序
* 1. 在for循环(循环变量为i)的每次迭代开始，子数组arr[1..i-1]都已经排序完成。
* 2. 剩余的元素arr[i..N]对应需要进行排序的元素。
* 3. 由于一张牌也可以代表已经排序完成，因此从i = 1开始往后迭代直到n，来进行排序。
* 4. 用变量key来标定当前需要进行排序的元素key = arr[i]
* 5. 模拟我们打牌时对牌进行排序的过程，每拿起一张新的牌，手里的牌都是已经排序好的，
*    因此我们只需要从右向左依次比较拿起的牌与手中牌的大小，当找到一个位置使得这个位置
*    之前的牌比它小，之后的牌比它大时，将牌插入。
* 6. 由于在计算机中内存是连续的，不可能在两个相邻的存储单元直接再插入一个单元，因此
*    因此，要将插入点之后的数据依次向后移动一个单元。
* 7. 定义一个变量j代表手中最右侧的最大的牌，由于我们需要依次向最左侧比较，因此可以定义一个while
*    循环来实现这个过程，循环中来实现5，6中的过程，进入循环的条件为手中的牌比当前需要比较的牌大，
*    同时为了避免越界访问的问题，需要j>=0，也就是只能比较到最左侧第一张牌为止。
* 7. 进入循环后，当插入点之后数据往后移动，移动完成后，将插入点处的数据进行赋值。
* 8. 进入下一次for循环
*/   

#define N 6
//升序排列
void insertion_sort1(int *arr)
{
  for(int i = 1; i < N; i++)
  {
    int key = arr[i];
    int j = i - 1;
    while(j >= 0 && arr[j] > key)
    {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
}
//降序排列
void insertion_sort2(int *arr)
{
  for(int i = 1; i < N; i++)
  {
    int key  = arr[i];
    int j = i - 1;
    while(j >=0 && arr[j] < key)
    {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
}


int main(void)
{
  int arr[N] = {5, 2, 4, 6, 1, 3};
  insertion_sort2(arr);
  for(int i = 0; i < N; i++)
  {
    printf("%d ", arr[i]);
  }
}
